<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;

    background-color: #fff;
    --elevated: #fff;
    --link: #0066cc;
    --text: #161616;
    --outline: #007aff;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      --elevated: #121212;
      --link: #58a6ff;
      --text: #fff;
    }
  }

  body {
    color: var(--text);
  }

  a {
    color: var(--link);
    text-decoration: underline;
    text-underline-offset: 4px;
    text-decoration-thickness: 1px;
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100dvh;
    font: 18px / 1.5 system-ui;
    font-size: var(--prompter-font-size, 18px);
    background-color: var(--prompter-bg, transparent);
    color: var(--prompter-fg, var(--text));
    tab-size: 4;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }

  .md-h1,
  .md-h2,
  .md-h3,
  .md-h4,
  .md-h5,
  .md-h6 {
    font-weight: 700;
  }

  .md-h1 {
    font-size: 2em;
  }

  .md-h2 {
    font-size: 1.5em;
  }

  .md-h3 {
    font-size: 1.25em;
  }

  .md-h4 {
    font-size: 1.1em;
  }

  .md-h5 {
    font-size: 1em;
  }

  .md-h6 {
    font-size: 0.9em;
  }

  .md-code {
    font-family: monospace;
  }

  .md-codeblock {
    font-family: monospace;
  }

  .md-bold {
    font-weight: bold;
  }

  .md-strike {
    text-decoration: line-through;
  }

  .md-italic {
    font-style: italic;
  }

  .md-url {
    cursor: pointer;
  }

  #button {
    -webkit-tap-highlight-color: transparent;
    background-color: #0569fa;
    border-radius: 50%;
    border: none;
    bottom: 15px;
    box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, .12);
    color: #fff;
    cursor: pointer;
    display: grid;
    font-weight: 600;
    width: 46px;
    height: 46px;
    outline: none;
    overflow: hidden;
    padding: 0;
    place-items: center;
    position: fixed;
    right: 15px;
    text-decoration: none;
    touch-action: manipulation;
    transition: background-color .3s ease-out;
    user-select: none;
    z-index: 1;
  }

  @media (hover) {
    #button:hover {
      color: #fff;
      background-color: #3c86f3;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, .12);
    }
  }

  #button:focus-visible {
    outline: 2px solid var(--outline);
    outline-offset: 2px;
  }

  #teleprompter-play {
    -webkit-tap-highlight-color: transparent;
    background-color: #34c759;
    border-radius: 50%;
    border: none;
    bottom: 15px;
    box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, .12);
    color: #fff;
    cursor: pointer;
    display: grid;
    place-items: center;
    width: 46px;
    height: 46px;
    outline: none;
    padding: 0;
    position: fixed;
    right: 69px;
    text-decoration: none;
    touch-action: manipulation;
    transition: background-color .3s ease-out;
    user-select: none;
    z-index: 1;
  }

  @media (hover) {
    #teleprompter-play:hover {
      background-color: #2fb84e;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, .12);
    }
  }

  #teleprompter-play:focus-visible {
    outline: 2px solid var(--outline);
    outline-offset: 2px;
  }

  body.prompter-mode #teleprompter-play {
    opacity: 0.35;
    background-color: rgba(0, 0, 0, 0.25);
  }

  body.prompter-mode #button {
    opacity: 0.35;
  }

  span.ripple {
    position: absolute;
    border-radius: 50%;
    transform: scale(0);
    animation: ripple 600ms linear;
    background-color: rgba(255, 255, 255, 0.7);
  }

  @keyframes ripple {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }

  #menu {
    visibility: hidden;
    transform: scale(0.9) translateY(20px);
    transition: all 100ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;
    display: flex;
    flex-direction: column;
    width: 220px;
    position: fixed;
    right: 16px;
    bottom: 77px;
    box-shadow: 0 19px 38px rgba(0, 0, 0, 0.10), 0 15px 12px rgba(0, 0, 0, 0.05);
    background: var(--elevated);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    z-index: 2;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  }

  #menu.visible {
    opacity: 1;
    transform: scale(1) translateY(0);
    visibility: visible;
  }

  #menu .item {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    text-decoration: none;
    text-align: left;
    padding: 10px 14px;
    overflow: hidden;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    outline: none;
    border: none;
    touch-action: manipulation;
    font: 16px / 1.5;
    color: var(--text);
  }

  #menu .item:hover {
    background-color: rgba(0, 0, 0, 0.04);
    @media (prefers-color-scheme: dark) {
      background-color: #353535;
    }
  }

  #menu .item:focus-within {
    outline: 2px solid var(--outline);
  }

  #menu .item:first-child {
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
  }

  #menu .item:last-child {
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
  }

  #menu .menu-version {
    padding: 8px 14px 12px;
    font-size: 11px;
    color: var(--text);
    opacity: 0.6;
    border-top: 1px solid rgba(0, 0, 0, 0.08);
  }
  @media (prefers-color-scheme: dark) {
    #menu .menu-version {
      border-top-color: rgba(255, 255, 255, 0.1);
    }
  }

  #notification {
    visibility: hidden;
    transform: translateY(-30px);
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;

    display: flex;
    flex-direction: column;

    position: fixed;
    right: 17px;
    top: 17px;

    background: #5ad227;
    color: #fff;
    border-radius: 30px;
    font: 18px / 1 system-ui;
    font-weight: 600;
    z-index: 2;
    padding: 10px 20px;
  }

  #notification.visible {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
  }

  @media print {
    .noprint {
      visibility: hidden !important;
    }
  }

  /* Teleprompter section inside menu */
  #menu .prompter-section {
    padding: 10px 14px 12px;
    border-top: 1px solid rgba(0, 0, 0, 0.08);
  }

  @media (prefers-color-scheme: dark) {
    #menu .prompter-section {
      border-top-color: rgba(255, 255, 255, 0.1);
    }
  }

  #menu .prompter-section .prompter-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text);
    opacity: 0.7;
    margin-bottom: 8px;
  }

  #menu .prompter-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }

  #menu .prompter-row:last-child {
    margin-bottom: 0;
  }

  #menu .prompter-section .toolbar-btn {
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.06);
    color: var(--text);
    cursor: pointer;
    display: grid;
    place-items: center;
    font-size: 14px;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.15s;
  }

  @media (prefers-color-scheme: dark) {
    #menu .prompter-section .toolbar-btn {
      background: rgba(255, 255, 255, 0.08);
    }
  }

  #menu .prompter-section .toolbar-btn:hover {
    background: rgba(0, 0, 0, 0.1);
  }

  @media (prefers-color-scheme: dark) {
    #menu .prompter-section .toolbar-btn:hover {
      background: rgba(255, 255, 255, 0.15);
    }
  }

  #menu .prompter-section .toolbar-btn.active {
    background: var(--outline);
    color: #fff;
  }

  #menu .prompter-section .prompter-checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text);
    user-select: none;
  }

  #menu .prompter-section .prompter-checkbox-label input {
    width: 18px;
    height: 18px;
    accent-color: var(--outline);
  }

  #menu .prompter-section .toolbar-btn.color-btn-wrap {
    padding: 0;
    overflow: hidden;
    position: relative;
    border: 1px solid rgba(0, 0, 0, 0.15);
  }

  @media (prefers-color-scheme: dark) {
    #menu .prompter-section .toolbar-btn.color-btn-wrap {
      border-color: rgba(255, 255, 255, 0.2);
    }
  }

  #menu .prompter-section .color-btn-wrap input[type="color"] {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    border: none;
    padding: 0;
    margin: 0;
    cursor: pointer;
    opacity: 0;
  }

  #menu .prompter-section .prompter-speed-row {
    align-items: center;
    gap: 6px;
  }

  #menu .prompter-section .speed-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text);
    opacity: 0.75;
    flex-shrink: 0;
  }

  #menu .prompter-section .speed-icon img {
    display: block;
    object-fit: contain;
  }

  #menu .prompter-section input[type="range"] {
    flex: 1;
    min-width: 0;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(0, 0, 0, 0.15);
    border-radius: 3px;
  }

  @media (prefers-color-scheme: dark) {
    #menu .prompter-section input[type="range"] {
      background: rgba(255, 255, 255, 0.2);
    }
  }

  #menu .prompter-section input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--outline);
    cursor: pointer;
  }

  /* Prompter mode: fullscreen reading */
  body.prompter-mode {
    overflow: hidden;
  }

  body.prompter-mode article {
    font-size: var(--prompter-font-size, 24px) !important;
    background-color: var(--prompter-bg, #000) !important;
    color: var(--prompter-fg, #fff) !important;
    contenteditable: false;
    padding: 20px max(20px, calc(50vw - 400px));
    min-height: 100dvh;
  }

  #key-debug {
    display: none;
    position: fixed;
    left: 10px;
    bottom: 90px;
    font: 12px/1.4 monospace;
    color: #fff;
    background: rgba(0,0,0,0.85);
    padding: 8px 10px;
    border-radius: 8px;
    z-index: 3;
    pointer-events: none;
    max-width: 90vw;
    min-height: 48px;
  }
  body.debug-keys-visible #key-debug {
    display: block;
  }

  article.prompter-mirror-h {
    transform: scaleX(-1);
  }

  article.prompter-mirror-v {
    transform: scaleY(-1);
  }

  article.prompter-mirror-h.prompter-mirror-v {
    transform: scale(-1, -1);
  }
</style>
<article contenteditable="plaintext-only" autofocus></article>
<button id="teleprompter-play" class="noprint" type="button" title="Start teleprompter" aria-label="Start teleprompter">
  <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
</button>
<button id="button" class="noprint">
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
       stroke="currentColor"
       stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="1"></circle>
    <circle cx="12" cy="5" r="1"></circle>
    <circle cx="12" cy="19" r="1"></circle>
  </svg>
</button>
<div id="menu" class="noprint" role="menu">
  <a class="item" href="#new" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-plus"></use>
    </svg>
    New document
  </a>
  <a class="item" id="qr" href="/qr" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-qrcode"></use>
    </svg>
    Generate QR code
  </a>
  <a class="item" id="share-link" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-share"></use>
    </svg>
    Share document
  </a>
  <a class="item" id="save-as-html" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as HTML
  </a>
  <a class="item" id="save-as-text" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as TEXT
  </a>
  <div class="prompter-section">
    <div class="prompter-label">Teleprompter</div>
    <div class="prompter-row">
      <button type="button" class="toolbar-btn" id="font-minus" title="Decrease font size" aria-label="Decrease font size">A−</button>
      <button type="button" class="toolbar-btn" id="font-plus" title="Increase font size" aria-label="Increase font size">A+</button>
      <button type="button" class="toolbar-btn" id="mirror-h" title="Mirror horizontally" aria-label="Mirror horizontally">⇄</button>
      <button type="button" class="toolbar-btn" id="mirror-v" title="Mirror vertically" aria-label="Mirror vertically">⇅</button>
      <span class="toolbar-btn color-btn-wrap" id="bg-color-wrap" title="Background color" aria-hidden="true">
        <input type="color" id="bg-color" title="Background color" aria-label="Background color" value="#000000">
      </span>
    </div>
    <div class="prompter-row prompter-spellcheck-row">
      <label class="prompter-checkbox-label">
        <input type="checkbox" id="spellcheck-toggle" aria-label="Spell check">
        <span>Spell check</span>
      </label>
    </div>
    <div class="prompter-row prompter-speed-row">
      <span class="speed-icon speed-slow" title="Slower" aria-hidden="true">
        <img src="assets/snail-slow.png" width="18" height="18" alt="">
      </span>
      <input type="range" id="speed-slider" min="20" max="500" value="50" title="Scroll speed" aria-label="Scroll speed">
      <span class="speed-icon speed-fast" title="Faster" aria-hidden="true">
        <img src="assets/lightning-fast.png" width="18" height="18" alt="">
      </span>
    </div>
    <div class="prompter-row prompter-spellcheck-row">
      <label class="prompter-checkbox-label">
        <input type="checkbox" id="debug-toggle" aria-label="Debug">
        <span>Debug</span>
      </label>
    </div>
  </div>
  <a class="item" href="https://github.com/itcaat/teleprompter" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-github"></use>
    </svg>
    GitHub
  </a>
  <div id="menu-version" class="menu-version" aria-hidden="true"></div>
</div>
<div id="key-debug" class="noprint" aria-hidden="true">Press any key (e.g. joystick)</div>
<div id="notification" class="noprint"></div>
<script>
  const APP_VERSION = '2026-02-09'

  initUI()

  const article = document.querySelector('article')
  const editor = new Editor(article, parseMarkdown)
  article.addEventListener('input', debounce(500, save))
  article.addEventListener('blur', save)
  article.addEventListener('click', event => {
    if (event.target.tagName === 'A') window.open(event.target.getAttribute('href'), '_blank')
  })
  addEventListener('DOMContentLoaded', () => {
    load()
    const ver = document.getElementById('menu-version')
    if (ver) ver.textContent = 'Version: ' + APP_VERSION
  })
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    const el = document.getElementById('key-debug')
    if (el) {
      const code = e.keyCode ?? e.which
      el.textContent = 'key: ' + JSON.stringify(e.key) + '\nkeyCode: ' + code + '\nwhich: ' + e.which + '\ncode: ' + (e.code || '')
    }
    if ((e.metaKey || e.ctrlKey) && e.code === 'KeyS') {
      e.preventDefault()
      downloadHTML()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  initTeleprompter()

  function initTeleprompter() {
    const STORAGE_KEY = 'teleprompter'
    const FONT_MIN = 14
    const FONT_MAX = 72
    const FONT_DEFAULT = 24
    const SPEED_MIN = 20
    const SPEED_MAX = 500
    const SPEED_DEFAULT = 50
    const JUMP_PX = 140
    const JUMP_MS = 180

    let prompterPlaying = false
    let scrollRAF = null
    let lastScrollTime = 0

    let state = {
      fontSize: FONT_DEFAULT,
      bgColor: '#000000',
      mirrorH: false,
      mirrorV: false,
      speed: SPEED_DEFAULT,
      spellcheck: false,
      debugKeys: false
    }

    try {
      const saved = localStorage.getItem(STORAGE_KEY)
      if (saved) {
        const parsed = JSON.parse(saved)
        state.fontSize = Math.max(FONT_MIN, Math.min(FONT_MAX, parsed.fontSize ?? FONT_DEFAULT))
        state.bgColor = parsed.bgColor ?? state.bgColor
        state.mirrorH = !!parsed.mirrorH
        state.mirrorV = !!parsed.mirrorV
        state.speed = Math.max(SPEED_MIN, Math.min(SPEED_MAX, parsed.speed ?? SPEED_DEFAULT))
        state.spellcheck = !!parsed.spellcheck
        state.debugKeys = !!parsed.debugKeys
      }
    } catch (e) {}

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
      } catch (e) {}
    }

    function applyPrompterStyles() {
      document.body.style.setProperty('--prompter-font-size', state.fontSize + 'px')
      document.body.style.setProperty('--prompter-bg', state.bgColor)
      const isDark = luminance(state.bgColor) < 0.4
      document.body.style.setProperty('--prompter-fg', isDark ? '#fff' : '#111')
    }

    function applyFontSize() {
      document.body.style.setProperty('--prompter-font-size', state.fontSize + 'px')
    }

    function applyBgColor() {
      document.body.style.setProperty('--prompter-bg', state.bgColor)
      const isDark = luminance(state.bgColor) < 0.4
      document.body.style.setProperty('--prompter-fg', isDark ? '#fff' : '#111')
    }

    function luminance(hex) {
      const n = parseInt(hex.slice(1), 16)
      const r = (n >> 16) / 255, g = ((n >> 8) & 0xff) / 255, b = (n & 0xff) / 255
      return 0.2126 * r + 0.7152 * g + 0.0722 * b
    }

    const fontMin = document.getElementById('font-minus')
    const fontPlus = document.getElementById('font-plus')
    const bgColorInput = document.getElementById('bg-color')
    const bgColorWrap = document.getElementById('bg-color-wrap')
    const mirrorHBtn = document.getElementById('mirror-h')
    const mirrorVBtn = document.getElementById('mirror-v')
    const speedSlider = document.getElementById('speed-slider')
    const spellcheckToggle = document.getElementById('spellcheck-toggle')
    const debugToggle = document.getElementById('debug-toggle')
    const playBtn = document.getElementById('teleprompter-play')
    const playIcon = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>'
    const pauseIcon = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>'

    bgColorInput.value = state.bgColor
    bgColorWrap.style.backgroundColor = state.bgColor
    speedSlider.value = state.speed
    mirrorHBtn.classList.toggle('active', state.mirrorH)
    mirrorVBtn.classList.toggle('active', state.mirrorV)
    spellcheckToggle.checked = state.spellcheck
    article.setAttribute('spellcheck', state.spellcheck ? 'true' : 'false')
    if (debugToggle) {
      debugToggle.checked = state.debugKeys
      document.body.classList.toggle('debug-keys-visible', state.debugKeys)
    }
    applyFontSize()
    applyBgColor()
    updateArticleMirror()

    fontMin.addEventListener('click', () => {
      state.fontSize = Math.max(FONT_MIN, state.fontSize - 2)
      saveState()
      applyFontSize()
      if (prompterPlaying) applyPrompterStyles()
    })
    fontPlus.addEventListener('click', () => {
      state.fontSize = Math.min(FONT_MAX, state.fontSize + 2)
      saveState()
      applyFontSize()
      if (prompterPlaying) applyPrompterStyles()
    })
    bgColorInput.addEventListener('input', () => {
      state.bgColor = bgColorInput.value
      bgColorWrap.style.backgroundColor = state.bgColor
      saveState()
      applyBgColor()
      if (prompterPlaying) applyPrompterStyles()
    })
    mirrorHBtn.addEventListener('click', () => {
      state.mirrorH = !state.mirrorH
      saveState()
      mirrorHBtn.classList.toggle('active', state.mirrorH)
      updateArticleMirror()
    })
    mirrorVBtn.addEventListener('click', () => {
      state.mirrorV = !state.mirrorV
      saveState()
      mirrorVBtn.classList.toggle('active', state.mirrorV)
      updateArticleMirror()
    })
    speedSlider.addEventListener('input', () => {
      state.speed = +speedSlider.value
      saveState()
    })
    spellcheckToggle.addEventListener('change', () => {
      state.spellcheck = spellcheckToggle.checked
      saveState()
      article.setAttribute('spellcheck', state.spellcheck ? 'true' : 'false')
    })
    if (debugToggle) {
      debugToggle.addEventListener('change', () => {
        state.debugKeys = debugToggle.checked
        saveState()
        document.body.classList.toggle('debug-keys-visible', state.debugKeys)
      })
    }

    function updateArticleMirror() {
      article.classList.toggle('prompter-mirror-h', state.mirrorH)
      article.classList.toggle('prompter-mirror-v', state.mirrorV)
    }

    function setPlayButtonPlaying(playing) {
      playBtn.innerHTML = playing ? pauseIcon : playIcon
      playBtn.title = playing ? 'Pause' : 'Start teleprompter'
      playBtn.setAttribute('aria-label', playing ? 'Pause' : 'Start teleprompter')
    }

    function startPrompter() {
      prompterPlaying = true
      setPlayButtonPlaying(true)
      document.querySelector('#menu').classList.remove('visible')
      document.body.classList.add('prompter-mode')
      article.setAttribute('contenteditable', 'false')
      applyPrompterStyles()
      updateArticleMirror()
      lastScrollTime = performance.now()
      function scrollStep(now) {
        if (!prompterPlaying) return
        const dt = (now - lastScrollTime) / 1000
        lastScrollTime = now
        const dy = state.speed * dt
        window.scrollBy(0, dy)
        scrollRAF = requestAnimationFrame(scrollStep)
      }
      scrollRAF = requestAnimationFrame(scrollStep)
    }

    function stopPrompter() {
      prompterPlaying = false
      setPlayButtonPlaying(false)
      if (scrollRAF != null) {
        cancelAnimationFrame(scrollRAF)
        scrollRAF = null
      }
      document.body.classList.remove('prompter-mode')
      article.setAttribute('contenteditable', 'plaintext-only')
      updateArticleMirror()
    }

    playBtn.addEventListener('click', () => {
      if (prompterPlaying) stopPrompter()
      else startPrompter()
    })

    function smoothScrollBy(dy) {
      const start = window.scrollY
      const startTime = performance.now()
      function step(now) {
        const t = Math.min((now - startTime) / JUMP_MS, 1)
        const ease = 1 - (1 - t) * (1 - t)
        window.scrollTo(0, start + dy * ease)
        if (t < 1) requestAnimationFrame(step)
      }
      requestAnimationFrame(step)
    }

    function smoothScrollTo(y) {
      const start = window.scrollY
      const startTime = performance.now()
      const dy = y - start
      function step(now) {
        const t = Math.min((now - startTime) / JUMP_MS, 1)
        const ease = 1 - (1 - t) * (1 - t)
        window.scrollTo(0, start + dy * ease)
        if (t < 1) requestAnimationFrame(step)
      }
      requestAnimationFrame(step)
    }

    document.addEventListener('keydown', e => {
      if (!document.body.classList.contains('prompter-mode')) return
      const el = document.getElementById('key-debug')
      if (el) {
        const code = e.keyCode ?? e.which
        el.textContent = 'key: ' + JSON.stringify(e.key) + '\nkeyCode: ' + code + '\nwhich: ' + e.which + '\ncode: ' + (e.code || '')
      }
      const code = e.keyCode ?? e.which
      const isUp = e.key === 'ArrowUp' || e.key === 'Up' || e.key === 'MediaFastForward' || code === 38 || code === 19 || code === 228
      const isDown = e.key === 'ArrowDown' || e.key === 'Down' || e.key === 'MediaRewind' || code === 40 || code === 20 || code === 227
      const isLeft = e.key === 'MediaTrackPrevious' || code === 177
      const isRight = e.key === 'MediaTrackNext' || code === 176
      if (isUp) {
        e.preventDefault()
        smoothScrollBy(-JUMP_PX)
      } else if (isDown) {
        e.preventDefault()
        smoothScrollBy(JUMP_PX)
      } else if (isLeft) {
        e.preventDefault()
        smoothScrollTo(0)
      } else if (isRight) {
        e.preventDefault()
        smoothScrollTo(document.documentElement.scrollHeight)
      }
    })
  }

  console.log('%cGitHub https://github.com/itcaat/teleprompter', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
    }
    updateTitle()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try {
      localStorage.setItem('hash', hash)
    } catch (e) {
    }
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    editor.set(content)
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = article.textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    const match = article.textContent.match(/^\n*#(.+)\n/)
    document.title = match?.[1] ?? 'Textarea'
  }

  async function compressDeflate(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompressDeflate(b64) {
    const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'})
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  async function compressBrotli(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('brotli')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompressBrotli(b64) {
    const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'})
    const stream = new DecompressionStream('brotli')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  // URL-safe base85: 5 chars per 4 bytes (shorter than base64's 4 chars per 3 bytes)
  const B85 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.-~_!'()*+,;=:@/?[]^`#<>"
  const B85_BASE = 86
  function encodeBase85(bytes) {
    let s = ''
    const pad = (4 - (bytes.length + 2) % 4) % 4
    const total = 2 + bytes.length + pad
    const buf = new Uint8Array(total)
    buf[0] = bytes.length >>> 8
    buf[1] = bytes.length & 255
    buf.set(bytes, 2)
    for (let i = 0; i < total; i += 4) {
      let n = (buf[i] << 24) | (buf[i + 1] << 16) | (buf[i + 2] << 8) | buf[i + 3]
      for (let j = 0; j < 5; j++) {
        s += B85[n % B85_BASE]
        n = (n / B85_BASE) | 0
      }
    }
    return s
  }
  function decodeBase85(s) {
    const buf = []
    for (let i = 0; i < s.length; i += 5) {
      let n = 0
      for (let j = 0; j < 5; j++) n += B85.indexOf(s[i + j]) * Math.pow(B85_BASE, j)
      buf.push((n >>> 24) & 255, (n >>> 16) & 255, (n >>> 8) & 255, n & 255)
    }
    const len = (buf[0] << 8) | buf[1]
    return new Uint8Array(buf.slice(2, 2 + len))
  }

  async function compress(string) {
    try {
      return 'b' + await compressBrotli(string)
    } catch (e) {
      const bytes = await compressDeflateToBytes(string)
      return 'z' + encodeBase85(bytes)
    }
  }

  async function compressDeflateToBytes(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer)
  }

  async function decompress(payload) {
    if (payload.startsWith('b')) {
      return await decompressBrotli(payload.slice(1))
    }
    if (payload.startsWith('z')) {
      const bytes = decodeBase85(payload.slice(1))
      const stream = new DecompressionStream('deflate-raw')
      const writer = stream.writable.getWriter()
      writer.write(bytes)
      writer.close()
      const buffer = await new Response(stream.readable).arrayBuffer()
      return new TextDecoder().decode(buffer)
    }
    return await decompressDeflate(payload)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  async function downloadHTML() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelectorAll('.noprint').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }

  async function downloadTXT() {
    updateTitle()
    const text = article.textContent

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.txt',
          types: [{
            description: 'TEXT file',
            accept: {'text/plain': ['.txt']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(text)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([text], {type: 'text/plain'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.txt'
    a.click()
    URL.revokeObjectURL(url)
  }

  function parseMarkdown(element) {
    const input = element.textContent
    const frag = document.createDocumentFragment()

    const matchers = [
      {name: 'md-codeblock', re: /```[^\n]*\n[\s\S]*?\n```/y},
      {name: 'md-codeblock', re: /~~~[^\n]*\n[\s\S]*?\n~~~/y},
      {name: 'md-h1', re: /^#[ \t]+[^\n]*$/my},
      {name: 'md-h2', re: /^##[ \t]+[^\n]*$/my},
      {name: 'md-h3', re: /^###[ \t]+[^\n]*$/my},
      {name: 'md-h4', re: /^####[ \t]+[^\n]*$/my},
      {name: 'md-h5', re: /^#####[ \t]+[^\n]*$/my},
      {name: 'md-h6', re: /^######[ \t]+[^\n]*$/my},
      {name: 'md-code', re: /`[^`\n]*`/y},
      {name: 'md-bold', re: /\*\*[^*\n]+?\*\*/y},
      {name: 'md-bold', re: /__[^_\n]+?__/y},
      {name: 'md-strike', re: /~~[^~\n]+?~~/y},
      {name: 'md-italic', re: /\*[^*\n]+?\*/y},
      {name: 'md-italic', re: /_[^_\n]+?_/y},
      {name: 'md-url', re: /https?:\/\/[^\s<>()\[\]{}"'`]+/y},
    ]

    const specials = ['`', '~', '*', '#', '_', 'h']

    let i = 0
    while (i < input.length) {
      let matched = false
      for (const m of matchers) {
        m.re.lastIndex = i
        const res = m.re.exec(input)
        if (res && res.index === i) {
          const raw = res[0]
          if (m.name === 'md-url') {
            const a = document.createElement('a')
            a.className = 'md-url'
            a.href = raw
            a.textContent = raw
            a.target = '_blank'
            a.rel = 'noopener noreferrer'
            frag.appendChild(a)
          } else {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw
            frag.appendChild(span)
          }
          i += raw.length
          matched = true
          break
        }
      }

      if (matched) continue

      let next = input.length
      for (const ch of specials) {
        const idx = input.indexOf(ch, i)
        if (idx !== -1 && idx < next) next = idx
      }

      if (next === i) {
        frag.appendChild(document.createTextNode(input[i]))
        i++
        continue
      }

      frag.appendChild(document.createTextNode(input.slice(i, next)))
      i = next
    }

    article.textContent = ''
    article.appendChild(frag)
    article.normalize()
  }

  function initUI() {
    const menu = document.querySelector('#menu')
    const button = document.querySelector('#button')
    const qr = document.querySelector('#qr')
    const shareLink = document.querySelector('#share-link')
    const saveAsHTML = document.querySelector('#save-as-html')
    const saveAsText = document.querySelector('#save-as-text')

    button.addEventListener('click', event => {
      if (event.clientX || event.targetTouches) ripple(event)
      menu.classList.toggle('visible')
      qr.setAttribute('href', '/qr' + location.hash)
      shareLink.setAttribute('href', location.href)
    })

    function hideMenu() {
      menu.classList.remove('visible')
    }

    function notify(message) {
      const notification = document.querySelector('#notification')
      notification.classList.add('visible')
      notification.textContent = message
      setTimeout(() => notification.classList.remove('visible'), 2e3)
    }

    document.body.addEventListener('click', event => {
      let t = event.target
      if (t.closest('#menu')) return
      if (t.closest('#button')) return
      if (t.closest('.ripple')) return
      menu.classList.remove('visible')
    })

    shareLink.addEventListener('click', event => {
      event.preventDefault()
      if (!navigator.clipboard) {
        alert('Your browser does not support clipboard API')
        return
      }
      navigator.clipboard.writeText(location.href)
      notify('Link copied')
      hideMenu()
    })
    saveAsHTML.addEventListener('click', event => {
      event.preventDefault()
      downloadHTML()
      hideMenu()
    })
    saveAsText.addEventListener('click', event => {
      event.preventDefault()
      downloadTXT()
      hideMenu()
    })
  }

  function ripple(event) {
    const button = event.currentTarget
    const circle = document.createElement('span')
    const diameter = Math.max(button.clientWidth, button.clientHeight)
    const radius = diameter / 2
    circle.style.width = circle.style.height = `${diameter}px`
    circle.style.left = `${(event.clientX || event.targetTouches[0].pageX) - button.offsetLeft - radius}px`
    circle.style.top = `${(event.clientY || event.targetTouches[0].pageY) - button.offsetTop - radius}px`
    circle.classList.add('ripple')
    const ripple = button.getElementsByClassName('ripple')[0]
    if (ripple) ripple.remove()
    button.appendChild(circle)
  }

  function Editor(element, highlight) {
    const listeners = []
    const history = []
    let at = -1, prev

    const debounceHighlight = debounce(30, () => {
      const pos = save()
      highlight(element)
      restore(pos)
    })

    const shouldRecord = (event) => {
      return !isUndo(event) && !isRedo(event)
        && event.key !== 'Meta'
        && event.key !== 'Control'
        && event.key !== 'Alt'
        && !event.key.startsWith('Arrow')
    }

    let recording = false
    const debounceRecordHistory = debounce(300, (event) => {
      if (shouldRecord(event)) {
        recordHistory()
        recording = false
      }
    })

    const on = (type, fn) => {
      listeners.push([type, fn])
      element.addEventListener(type, fn)
    }
    on('keydown', event => {
      if (event.defaultPrevented) return
      prev = toString()
      if (isUndo(event)) doUndo(event)
      if (isRedo(event)) doRedo(event)
      if (shouldRecord(event) && !recording) {
        recordHistory()
        recording = true
      }
    })
    on('keyup', event => {
      if (event.defaultPrevented) return
      if (event.isComposing) return
      if (prev !== toString()) debounceHighlight()
      debounceRecordHistory(event)
    })
    on('paste', () => setTimeout(recordHistory, 10))
    on('cut', () => setTimeout(recordHistory, 10))
    on('beforeinput', event => {
      if (event.inputType === 'historyUndo') doUndo(event)
      if (event.inputType === 'historyRedo') doRedo(event)
    })

    function save() {
      const s = getSelection()
      const pos = {start: 0, end: 0, dir: undefined}
      let {anchorNode, anchorOffset, focusNode, focusOffset} = s
      if (!anchorNode || !focusNode) throw 'error1'
      if (anchorNode === element && focusNode === element) {
        pos.start = (anchorOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.end = (focusOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-'
        return pos
      }
      if (anchorNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset])
        anchorNode = node
        anchorOffset = 0
      }
      if (focusNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        focusNode.insertBefore(node, focusNode.childNodes[focusOffset])
        focusNode = node
        focusOffset = 0
      }
      visit(element, el => {
        if (el === anchorNode && el === focusNode) {
          pos.start += anchorOffset
          pos.end += focusOffset
          pos.dir = anchorOffset <= focusOffset ? '->' : '<-'
          return 'stop'
        }
        if (el === anchorNode) {
          pos.start += anchorOffset
          if (!pos.dir) {
            pos.dir = '->'
          } else {
            return 'stop'
          }
        } else if (el === focusNode) {
          pos.end += focusOffset
          if (!pos.dir) {
            pos.dir = '<-'
          } else {
            return 'stop'
          }
        }
        if (el.nodeType === Node.TEXT_NODE) {
          if (pos.dir !== '->') pos.start += el.nodeValue.length
          if (pos.dir !== '<-') pos.end += el.nodeValue.length
        }
      })

      element.normalize()
      return pos
    }

    function restore(pos) {
      const s = getSelection()
      let startNode, startOffset = 0
      let endNode, endOffset = 0

      if (!pos.dir) pos.dir = '->'
      if (pos.start < 0) pos.start = 0
      if (pos.end < 0) pos.end = 0

      if (pos.dir === '<-') {
        const {start, end} = pos
        pos.start = end
        pos.end = start
      }

      let current = 0

      visit(element, el => {
        if (el.nodeType !== Node.TEXT_NODE) return

        const len = (el.nodeValue || '').length
        if (current + len > pos.start) {
          if (!startNode) {
            startNode = el
            startOffset = pos.start - current
          }
          if (current + len > pos.end) {
            endNode = el
            endOffset = pos.end - current
            return 'stop'
          }
        }
        current += len
      })

      if (!startNode) {
        startNode = element
        startOffset = element.childNodes.length
      }
      if (!endNode) {
        endNode = element
        endOffset = element.childNodes.length
      }

      if (pos.dir === '<-') {
        [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset]
      }

      {
        const startEl = uneditable(startNode)
        if (startEl) {
          const node = document.createTextNode('')
          startEl.parentNode?.insertBefore(node, startEl)
          startNode = node
          startOffset = 0
        }
        const endEl = uneditable(endNode)
        if (endEl) {
          const node = document.createTextNode('')
          endEl.parentNode?.insertBefore(node, endEl)
          endNode = node
          endOffset = 0
        }
      }

      s.setBaseAndExtent(startNode, startOffset, endNode, endOffset)
      element.normalize()
    }

    function uneditable(node) {
      while (node && node !== element) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.getAttribute('contenteditable') === 'false') {
            return node
          }
        }
        node = node.parentNode
      }
    }

    function doUndo(event) {
      preventDefault(event)
      at--
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at < 0) at = 0
    }

    function doRedo(event) {
      preventDefault(event)
      at++
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at >= history.length) at--
    }

    function recordHistory() {
      const html = element.innerHTML
      const pos = save()
      const lastRecord = history[at]
      if (
        lastRecord
        && lastRecord.html === html
        && lastRecord.pos.start === pos.start
        && lastRecord.pos.end === pos.end
      ) return
      at++
      history[at] = {html, pos}
      history.splice(at + 1)
      const maxHistory = 10_000
      if (at > maxHistory) {
        at = maxHistory
        history.splice(0, 1)
      }
    }

    function visit(editor, visitor) {
      const queue = []
      if (editor.firstChild) queue.push(editor.firstChild)
      let el = queue.pop()
      while (el) {
        if (visitor(el) === 'stop') break
        if (el.nextSibling) queue.push(el.nextSibling)
        if (el.firstChild) queue.push(el.firstChild)
        el = queue.pop()
      }
    }

    function isCtrl(event) {
      return event.metaKey || event.ctrlKey
    }

    function isUndo(event) {
      return isCtrl(event) && !event.shiftKey && event.code === 'KeyZ'
    }

    function isRedo(event) {
      return isCtrl(event) && event.shiftKey && event.code === 'KeyZ'
    }

    function toString() {
      return element.textContent || ''
    }

    function preventDefault(event) {
      event.preventDefault()
    }

    function getSelection() {
      return element.getRootNode().getSelection()
    }

    return {
      set(content) {
        element.textContent = content
        highlight(element)
      },
      destroy() {
        for (const [type, fn] of listeners) editor.removeEventListener(type, fn)
      },
    }
  }
</script>
<svg style="display: none" aria-hidden="true" focusable="false">
  <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"
          class="icon icon-tabler icons-tabler-outline icon-tabler-plus">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M12 5l0 14"/>
    <path d="M5 12l14 0"/>
  </symbol>
  <symbol id="icon-share" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
          stroke-linecap="round"
          stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1"/>
    <path d="M12 14v-11"/>
    <path d="M9 6l3 -3l3 3"/>
  </symbol>
  <symbol id="icon-qrcode" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 17l0 .01"/>
    <path d="M14 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 7l0 .01"/>
    <path d="M4 15a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M17 7l0 .01"/>
    <path d="M14 14l3 0"/>
    <path d="M20 14l0 .01"/>
    <path d="M14 14l0 3"/>
    <path d="M14 20l3 0"/>
    <path d="M17 17l3 0"/>
    <path d="M20 17l0 3"/>
  </symbol>
  <symbol id="icon-github" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path
      d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"/>
  </symbol>
  <symbol id="icon-empty" viewBox="0 0 24 24"></symbol>
</svg>
